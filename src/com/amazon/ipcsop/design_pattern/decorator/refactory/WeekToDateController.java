/**
 * 
 * 
 * Decorator装饰模式是一种结构型模式，它主要是解决：“过度地使用了继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀（多继承）。继承为类型引入的静态特质的意思是说以继承的方式使某一类型要获得功能是在编译时。所谓静态，是指在编译时；动态，是指在运行时。
GoF《设计模式》中说道：动态的给一个对象添加一些额外的职责。就增加功能而言，Decorator模式比生成子类更为灵活。


 * 将装饰模式搬移到Decorator
 * 意图：代码向类的核心职责提供装饰功能。将装饰代码搬移到Decorator。
 
动机：把每个装饰功能放在单独的类中，并让这个类包装它所要装饰的对象，因此当需要执行特殊行为时，客户代码就可以在运行时使用装饰功能包装对象。
 
优点和缺点：
＋把装饰功能从类中搬移去除，从而简化子类。
＋有效地把类地核心职责和装饰功能区分开来。
＋可以去除几个相关类中重复地装饰逻辑。
－改变了被装饰对象地对象类型。
－会使代码变得更难理解和调试。
－当Decorator组合产生负面影响的时候，会增加设计的复杂度。
 
做法：
1、确定或创建包装类型、接口或类，它声明了客户代码需要的被修饰类的公共方法。
2、找到为被修饰类添加装饰功能的条件逻辑，并应用用多态替换条件式重构去除这些逻辑。
3、步骤2产生了被修饰类的一个或多个子类。应用用委托替代继承重构把这些子类转换成委托类。
4、每个委托类都用被修饰类的新建实例对自己的委托字段进行了赋值。确保这个赋值逻辑语句在委托类的构造函数。
然后提取参数重构提取赋值语句中实例化被修饰类的部分。如果可能的话，重复应用移除构造函数中不必要的参数。

 */
package com.amazon.ipcsop.design_pattern.decorator.refactory;

/**
 * @author erfeiliu
 *
 */
public class WeekToDateController {
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		WeekToDateBase wtd = new WeekToDateBase();
		WeekToDateEU wtd_eu = new WeekToDateEU();
		wtd_eu.setWeekToDate(wtd);
		wtd_eu.SummaryTable();
	}
	
}
