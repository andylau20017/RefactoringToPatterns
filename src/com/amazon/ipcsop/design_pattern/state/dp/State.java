package com.amazon.ipcsop.design_pattern.state.dp;

//GOF《设计模式》中给状态模式下的定义为：允许一个对象在其内部状态改变时改变它的行为。这个对象看起来似乎修改了它的类。看起来，状态模式好像是神通广大――居然能够“修改自身的类”！
//
//能够让程序根据不同的外部情况来做出不同的响应，最直接的方法就是在程序中将这些可能发生的外部情况全部考虑到，使用if else 语句来进行代码响应选择。但是这种方法对于复杂一点的状态判断，就会显得杂乱无章，容易产生错误；而且增加一个新的状态将会带来大量的修改。这个时候“能够修改自身”的状态模式的引入也许是个不错的主意。
//
//状态模式可以有效的替换充满在程序中的if else语句：将不同条件下的行为封装在一个类里面，再给这些类一个统一的父类来约束他们。来看一下状态模式的角色组成吧：
//
//1) 使用环境（Context）角色：客户程序是通过它来满足自己的需求。它定义了客户程序需要的接口；并且维护一个具体状态角色的实例，这个实例来决定当前的状态。 
//
//2) 状态（State）角色：定义一个接口以封装与使用环境角色的一个特定状态相关的行为。
//
//3) 具体状态（Concrete State）角色：实现状态角色定义的接口。

//状态和行为是相关联的，可以描述为：状态决定行为。
//
//状态模式和策略模式的结构师完全一样的，但它们的目的、实现、本质却完全不一样。
//状态模式的行为是平行的，不可相互替换的；而策略模式的行为是平等性的，是可以相互替换的。


public interface State {
	public void handle(String sampleParameter);
}
